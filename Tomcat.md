## Tomcat类加载机制

- 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 

- 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。 

- web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 

- web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。

**因此它使用默认的类加载机制是不行的！**

因为默认的类加载机制无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。



Tomcat中基本的ClassLoader层级关系如下图所示：

![img](https://images2018.cnblogs.com/blog/137084/201805/137084-20180526104342525-959933190.png)

上面的三个类加载器：CommonClassLoader、CatalinaClassLoader和SharedClassLoader是与具体部署的Web应用无关的，而**WebappClassLoader则对应Web应用**，**每个Web应用都会有独立的类加载器**，从而实现类的隔离。

它也违背了双亲委派模型，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。

Tomcat的类加载

![img](https://images0.cnblogs.com/blog2015/449064/201506/141304597074685.jpg)

**webapp 应用类加载器：**每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。

　　**当应用需要到某个类时，则会按照下面的顺序进行类加载**：

　　1 使用bootstrap引导类加载器加载

　　2 使用system系统类加载器加载

　　**3 使用应用类加载器在WEB-INF/classes中加载**

　　**4 使用应用类加载器在WEB-INF/lib中加载**

　　**5 使用common类加载器在CATALINA_HOME/lib中加载**