## 为什么默认是非公平锁

因为为了避免唤醒带来的空档期。因为如果是公平锁，需要把等待队列里面的线程唤醒，这有一个空档期；如果是非公平锁，有可能某个线程强到这个锁并且在队列里线程唤醒的时间中执行完毕，然后给唤醒的线程使用。

特例：

tryLock可以插队，不管公平锁

公平锁源码中会有一个判断，判断队列是否有线程等待，如果没有则尝试获取。



## 为什么用Lock

Lock并不是代替synchronized的，而是synchronized不合适或不足以满足要求，来提供高级功能

### 为什么synchronized不够用？

- 效率低：锁的释放情况少、试图获得锁时不能设置超时时间、不能中断一个正在试图获得锁的线程。
- 不够灵活：加锁和释放锁时机单一，不如读写锁灵活
- 无法直到是否成功获得到锁



## 读写锁ReentrantReadWriteLock

适合读多写少的场景，比如白名单列表，配置文件等

- **插队策略**：非公平情况下，假设线程2和4正在同时读取，线程3想要写入，拿不到锁，进入等待队列，线程5不在队列中，它现在想要读取。ReentrantReadWriteLock的策略是不允许5插队，排在线程3的后面，防止线程3饥饿。

  总结：公平锁不允许插队；非公平锁：1. **写锁可以随时插队**。2. 读锁**仅在等待队列头结点不是想获取写锁的线程**的时候可以插队

  公平锁的情况：

```Java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() { //写锁是否阻塞?
        return hasQueuedPredecessors();
    }
    final boolean readerShouldBlock() { //读锁是否阻塞?
        return hasQueuedPredecessors();
    }
}
```

非公平锁的情况：

```Java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    final boolean writerShouldBlock() { //写锁总是插队
        return false; // writers can always barge
    }
    final boolean readerShouldBlock() {
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        return apparentlyFirstQueuedIsExclusive(); //判断队列中的第一个是否是排他锁（写锁）线程！！！！！
    }
}
```

- **写锁可以降级为读锁，但是读锁不能升级为写锁**

锁降级就是在持有写锁的同时获得了读锁，此时直接释放写锁，但是不释放读锁，这样可以提高锁的利用率。

**锁降级的意义在于，不用彻底释放锁，这样就能始终持有锁，不担心被抢**

但是在获得读锁的情况下不能同时获得写锁，这就是不支持升级，必须先释放读锁再获得写锁。

在更新缓存的时候可以利用锁的降级功能

```java
class CachedData {
    Object data;
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    void processCachedData() {
        //最开始是读取
        rwl.readLock().lock();
        if (!cacheValid) {
            //发现缓存失效，需要写入，因此需要获得写锁
            //必须在加写锁之前释放读锁
            rwl.readLock().unlock();
            //获取写锁
            rwl.writeLock().lock();
            try {
                //双重检查，有可能释放读锁和获取写锁的间隙内其他线程修改了缓存
                if (!cacheValid) {
                    //设置值
                    data = new Object();
                    cacheValid = true;
                }
                //在不释放写锁的情况下，直接获取读锁，进行写锁的降级
                rwl.readLock().lock();
            } finally {
                //释放写锁，但是仍然持有写锁，这样就可以多个线程同时读取，提高整体效率
                rwl.writeLock().unlock(); // Unlock write, still hold read
            }
        }
        try {
            use(data);
        } finally {
            //释放读锁
            rwl.readLock().unlock();
        }
    }
}
```

processCachedData 方法，在这个方法中，会首先获取到读锁，也就是 rwl.readLock().lock()，它去判断当前的缓存是否有效，如果有效那么就直接跳过整个 if 语句，如果已经失效，代表我们需要更新这个缓存了。由于我们需要更新缓存，所以之前获取到的读锁是不够用的，我们需要获取写锁。 在获取写锁之前，我们首先释放读锁，然后利用 rwl.writeLock().lock() 来获取到写锁，然后是经典的 try finally 语句，在 try 语句中我们首先判断缓存是否有效，因为在刚才释放读锁和获取写锁的过程中，可能有其他线程抢先修改了数据，所以在此我们需要进行二次判断。 如果我们发现缓存是无效的，就用 new Object() 这样的方式来示意，获取到了新的数据内容，并把缓存的标记位设置为 ture，让缓存变得有效。由于我们后续希望打印出 data 的值，所以不能在此处释放掉所有的锁。我们的选择是在不释放写锁的情况下直接获取读锁，也就是 rwl.readLock().lock() 这行语句所做的事情，然后，在持有读锁的情况下释放写锁，最后，在最下面的 try 中把 data 的值打印出来。

**为什么不能升级呢？**

因为必须等到所有读锁都释放才能升级，因此如果两个线程都想升级，那么都互相等待对方释放读锁，造成死锁！

`读写锁不能共存指的是多个线程不能同时获得读锁和写锁，但是降级的时候一个线程可以既有读锁又有写锁`

## 自旋锁和阻塞锁

自旋锁，线程不释放CPU，不停检测锁，避免线程切换的开销

阻塞锁，获得不到锁，就是阻塞线程，直到被唤醒

自旋锁使用场景：

1. 适用于**多核服务器**，在**并发度不是很高**的情况下，比阻塞锁效率高
2. 适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久才释放），也是不合适的

## 可中断锁

synchronized是不可中断锁，Lock就是可中断锁，因为trylock(time)和lockInterruptibly都能响应中断。就是在获取锁的过程中可以被中断！

## 锁优化

- 自旋锁和自适应：自旋锁在尝试多次后还未获得，JVM可以给他转为阻塞锁，这个转换的参数也是可以设置的
- 锁消除：JVM会知道一些场景下根本不必要加锁，比如这段代码，所有同步都在方法内部，根本不可能被别人访问，JVM会直接消除这个锁
- 锁粗化：如果一系列操作都是对一个对象加锁和加锁，JVM会动态监测前后相邻的synchronized代码块，如果使用的是同一个锁对象，就会合为一个，无需反复申请

## 写代码的时候如何优化锁提高性能

- 缩小同步代码块
- 尽量不要锁住方法
- 减少请求锁的次数
- 锁中不要再包含锁
- 选择合适的锁类型或合适的工具类

## 为什么Synchronized是不可中断的，ReentrantLock是可中断的

**synchronized只有获取到锁之后才能中断，等待锁时不可中断。**

ReentrantLock如果使用ReentrantLock.lockInterruptibly()来获取锁是可以被中断的

Java的中断是用Thread.interrupt()来操作的，看其源码可以发现，这里面的操作只是做了修改一个中断状态值为true，并没有显式声明抛出`InterruptedException`异常。

```java
/**
 * <p> If this thread is blocked in an invocation of the {@link
 * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
 * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
 * class, or of the {@link #join()}, {@link #join(long)}, {@link
 * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
 * methods of this class, then its interrupt status will be cleared and 
 * it will receive an {@link InterruptedException}.
 * 翻译：如果此线程被以下命令（wait、join、sleep）阻塞，他的中断状态会被
 * 清除并且会抛出InterruptedException异常
 *
 * <p> If none of the previous conditions hold then this thread's 
 * interrupt status will be set. </p>
 * 翻译：如果前面的条件都不满足那么将设置它的中断状态
 */
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();   // 检查权限

    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // 它是一个native方法, Just to set the interrupt flag
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}
```

中断操作只是给线程的一个建议，最终怎么执行看线程本身的状态，那么什么状态做什么事情呢？

- 若线程被中断前，如果该线程处于**非阻塞状态**(未调用过`wait`,`sleep`,`join`方法)，那么该线程的中断状态将被设为true， 除此之外，不会发生任何事。
- 若线程被中断前，该线程处于**阻塞状态**(调用了`wait`,`sleep`,`join`方法)，那么该线程将会立即从阻塞状态中退出，并抛出一个`InterruptedException`异常，同时，该线程的中断状态被设为false，除此之外，不会发生任何事。

所以说，`Synchronized`锁此时为轻量级锁或重量级锁，此时等待线程是在自旋运行或者已经是重量级锁导致的阻塞状态了（非调用了`wait`,`sleep`,`join`等方法的阻塞），**只把中断状态设为true，没有抛出异常真正中断。**

那为什么ReentrantLock可以被中断（未获取到锁也可中断）？

看看lockInterruptibly源码

```java
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);  // 调用可中断的获取锁方法
}

public final void acquireInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())    // 获取锁时检查中断状态
        // 显式抛中断异常
        throw new InterruptedException();
    if (!tryAcquire(arg))   // 获取不到锁，执行doAcquireInterruptibly
        doAcquireInterruptibly(arg);
}
private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    // 把线程放进等待队列
    final Node node = addWaiter(Node.EXCLUSIVE); 
    boolean failed = true;
    try {
        // 自旋
        for (;;) {
            // 获取前置节点
            final Node p = node.predecessor();
            // 前置节点为头节点 && 当前节点获取到锁
            if (p == head && tryAcquire(arg)) {
                // 当前节点设为头节点
                setHead(node);
                p.next = null;  // 应用置null,便于GC
                failed = false;
                // 结束自旋
                return;
            }
            // 检查是否阻塞线程 && 检查中断状态
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                // 显式抛中断异常
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}     
```

从源码可以知道，`ReentrantLock.lockInterruptibly()`首次尝试获取锁之前就**会判断是否应该中断**，如果没有获取到锁，在**自旋等待的时候也会继续判断中断状态**。这时`lockInterruptibly`底层再**显式抛错**，而不是像`Synchronized`那样交由线程自己决定是否抛错。当然`lockInterruptibly`获取到锁之后，也是得交由线程自己决定。