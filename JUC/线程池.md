## 为什么需要线程池

java语言的一个线程直接对应操作系统中的一个线程，如果我们通过for循环创建1000个线程，就相当于在操作系统中创建了1000个线程。开销非常的高，需要JVM和操作系统提供辅助操作，而且回收1000个线程也会给垃圾回收器带来压力。

<font color='red'>**好处：**</font>

- 加快响应速度
- 合理利用CPU和内存：线程既不太多也不太少
- 统一管理

## 线程池构造函数参数

```Java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
```

|    参数名     | 类型                     | 含义                                                      |
| :-----------: | :----------------------- | :-------------------------------------------------------- |
| corePoolSize  | int                      | 核心线程数                                                |
|  maxPoolSize  | int                      | 最大线程数                                                |
| keepAliveTime | long                     | 保持存活时间                                              |
|   workQueue   | BlockingQueue            | 任务存储队列                                              |
| threadFactory | ThreadFactory            | 当线程池需要新线程的时候，使用threadFactory来生成新的线程 |
|    Handler    | RejectedExecutionHandler | 由于线程池无法接受你所提交的任务的拒绝策略                |

### corePoolSize、maxPoolSize

一直存活在线程池中的线程，即使没有任务

![image-20200829172456487](D:\Typora\picture\image-20200829172456487.png)

**<font color='red'>线程添加规则：</font>**

1. 如果线程数小于corePoolSize，即使其他工作线程处于空闲，也会**创建一个新的线程**来执行任务
2. 如果线程数等于（大于）corePoolSize但少于maxPoolSize，则**将任务放入队列**
3. 如果队列已满，并且**线程数小于maxPoolSize**，则创建一个新线程来运行任务
4. 如果队列已满，并且**线程数大于等于maxPoolSize**，则**拒绝该任务**

**<font color='red'>增减线程特点：</font>**

1. 通过设置corePoolSize和maxPoolSize相同，可以创建固定大小线程池
2. 通过设置maxPoolSize为很高的值，可以允许线程池容纳任意数量并发任务
3. 使用无界队列（如LinkedBlockingQueue），线程数就不会超过corePoolSize

**<font color='green'>问题：</font>**

1. 队列满了之后，线程源源不断的来，那么队列里的任务就一直得不到执行了？

如果队列满了，在不超过maxPoolSize的情况下会创建线程，然后**消费队列头的任务**，也就是说新任务来了必须经过队列。

2. 当前有线程空闲，是去消费队列里面的线程吗？

是

### keepAliveTime

如果线程池当前线程数多于corePoolSize，那么多出来的这部分的线程空闲时间超过keepAliveTime，就会被回收。

**<font color='green'>问题：</font>**

1. 线程执行完任务如何知道自己等待了keepAliveTime时间，然后销毁的？

如果线程在获取任务时，如果队列已经没有任务了，会在此阻塞keepAliveTime时间，如果还没有任务就会return null，然后在 runWorker() 方法中执行 processWorkerExit(w, completedAbruptly) 终止线程。

### threadFactory

用来创建线程，默认的线程工厂创建出来的线程都在一个线程组，拥有同样的优先级，都不是守护线程。如果有必要也可以自己指定ThreadFactory。通常默认就行

### workQueue

3种常见队列类型：

1. 直接交换：SynchronousQueue，任务不是特别多，队列只做个简单的中转，**可以认为没有容量**，那么maxPoolSize需要设置大一点，因为没有队列缓冲了
2. 无界队列：LinkedBlockingQueue，可以防止流量突增，但是风险是处理速度跟不上任务提交速度，可能会造成内存浪费、OOM
3. 有界队列：ArrayBlockingQueue，可以设置队列大小

## FixedThreadPool

固定数量线程池

```java 
ExecutorService executorService = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    executorService.execute(new Task());
}
```

即使任务数量很多，但是只会有10个线程来执行，不会创建更多的线程，看看源码：

```Java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

因为maxPoolSize和corePoolSize，所以它不会创建更多线程，同时它使用无界队列，有可能当请求越来越多的时候，占用大量内存，导致OOM错误

## SingleThreadExecutor

```java 
ExecutorService executorService = Executors.newSingleThreadExecutor();
```

这个线程池里面只有一个线程！

```Java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

核心数量和最大数量都是1，和FixedThreadPool很类似

## CachedThreadPool

```Java
ExecutorService executorService = Executors.newCachedThreadPool();
```

- 可缓存线程池：这个Cache指的是对线程的缓存，如果一段时间空闲，就回收
- 无界线程池、具有自动回收多余线程的功能

```Java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

可以看到核心数量为0，maxPoolSize设置为最大，队列使用没有容量的SynchronousQueue，说明它会一直创建线程，然后没有任务执行了，就会回收线程。

弊端就是无限创建线程会导致OOM

## ScheduledThreadPool

支持定时以及周期性任务执行的线程池

```Java
ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        /** 5s之后执行 */
        threadPool.schedule(new FixedThreadPoolTest.Task(), 5, TimeUnit.SECONDS);
        /** 5s之后执行，然后每隔3s执行一次 */
        threadPool.scheduleAtFixedRate(new FixedThreadPoolTest.Task(), 5, 3, TimeUnit.SECONDS);
    }
```

```Java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

它使用的是延迟队列，设置的keepAliveTime是0，因为它任务是周期性的，设置为0可以快速回收

可以用它执行定时任务，或者替代定时器

## 线程池数量如何设定

- CPU密集型（加密、计算Hash）：最佳线程数为CPU核心数的<font color='red'>1~2倍</font>左右
- 耗时IO型（读写数据库、文件、网络读写）：最佳线程数一般大于CPU核心数很多倍，CPU经常不工作的，很多线程都在等待状态。可以设置为<font color='red'>CPU核心数*(1+平均等待时间/平均工作时间)</font>

## 如何停止线程池

1. shutdown：告知线程池需要停止，等所有任务都执行完就结束，然后拒绝新的任务。
2. isShutDown：表示是否开始停止（不一定全部执行完）
3. isTerminated：表示整个程序是否所有任务都执行完毕
4. awaitTermination：awaitTermination(3L, TimeUnit.SECONDS);表示3s之内所有任务是否执行完毕
5. shutdownNow：立刻关闭线程池。如果线程正在执行，给线程**传递interrupt信号中断它**，如果任务还在队列中等待，**直接返回**。会返回List<Runnable> ，可以把这些没有执行的任务记录下来

## 任务拒绝

### 拒绝时机：

- 线程池shutdown
- 线程池队列满，且线程数达到maxPoolSize

### 拒绝策略：

1. AbortPolicy：抛出异常，表示没有提交成功。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。
2. DiscardPolicy：默默丢弃，不会告诉我们任务没有处理。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。
3. DiscardOldestPolicy：丢弃队列中存在时间最久的。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。
4. CallerRunsPolicy：谁提交的谁去运行。一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。

## 线程池状态

- RUNNING：接受新任务并且处理阻塞队列里的任务
- SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务
- STOP：拒绝新任务，并且抛弃阻塞队列里的任务，同时会中断正在处理的任务。（ShutDownNow）
- TIDYING：中文意思是整洁，所有任务都执行完（包含阻塞队列里面任务）当前线程池活动线程为0，workerCount为0，将要调用terminated方法来终止线程池
- TERMINATED：终止状态。terminated方法调用完成以后的状态，线程池不能再恢复

## Executor实现原理

![image-20200829201517392](D:\Typora\picture\image-20200829201517392.png)

Executor是顶层接口，只有一个execute方法，用来执行任务

ExecutorService继承了Executor的方法，然后又增加了shutdown等方法，可以初步管理线程池，也是Executors返回的类型。



Executors是一个工具类，快速创建线程池。调用ThreadPoolExecutor的构造方法

**<font color='red'>线程池组成部分：</font>**

- 线程池管理器
- 工作线程
- 任务队列
- 任务接口（Task）

## 线程池注意点

- 避免任务堆积
- 避免线程数过度增加
- 排查线程泄漏：线程泄漏就是线程结束了但是没被回收，一般是任务写的逻辑不对

# 线程池的原理

相同的线程执行不同任务，线程池中的线程的run方法，它是不停检测有没有新的任务，有的话调用新的任务的run方法

## execute

看看源码：先看这个execute方法，他是调用线程池执行一个任务

```Java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //获取当前线程池状态以及线程个数，32位，前3位表状态，后29位表个数
    int c = ctl.get();
    //1. 如果当前线程数小于核心线程数，就加一个新的线程
    if (workerCountOf(c) < corePoolSize) {
        //增加新的线程，command就是任务,如果添加成功就返回
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //运行到这里说明核心线程数已满
    //2. 线程处于RUNNING状态，添加任务到阻塞队列，如果队列没有满就会添加成功
    if (isRunning(c) && workQueue.offer(command)) {
        //二次检查
        int recheck = ctl.get();
        //如果此时线程池关闭了，就把任务从任务队列中移出，并执行拒绝策略
        if (! isRunning(recheck) && remove(command))
            reject(command);
        //如果当前线程池是空，为什么会是0呢，因为线程有可能抛异常，导致线程停止，主要是防止任务提交到队列里面没有线程来执行
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //3. 新增线程，失败则执行拒绝策略（如果线程池达到最大值就会失败）
    else if (!addWorker(command, false))
        reject(command);
}
```

## addWorker

看看增加线程addWorker

```java 
//core：true使用corePoolSize为最大容量，false使用maximumPoolSize为最大容量
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 检查当前线程池状态是否是SHUTDOWN、STOP、TIDYING或者TERMINATED
        // 且 ！（当前状态为SHUTDOWN、且传入的任务为null，且队列不为null）
        //都成立返回false，拒绝添加新的线程
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            //如果当前线程数量超过最大容量或者大于（核心线程数或最大线程数），返回false
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //使用CAS方法把Worker数量+1
            if (compareAndIncrementWorkerCount(c))
                break retry;
            //CAS失败执行下面方法，查看当前线程数是否变化，变化则继续retry循环，没变化则继续内部循环
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
    
    // 运行到此处时，线程池线程数已经成功+1。

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        //这个Worker就是线程池中工作的类！！！！可理解为一个线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                //重新检查线程池状态
                //避免ThreadFactory退出故障或者在锁获取前线程池被关闭
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //向工作集合添加新的Worker
                    workers.add(w);
                    /* 防止溢出 */
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                //提交任务的线程启动了Worker类中的Thread！！！！！
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

主要是增加线程池个数、将任务添加到Worker里面，然后Worker添加到WorkerSet里面

## Worker

Worker就是线程池中线程包装类，就是线程池中工作的类。

继承了AQS实现了Runnable接口

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    //执行任务的线程类
    final Thread thread;
    //初始化执行的任务，第一次执行的任务，worker启动后优先执行firstTask的任务，提交的这个task会设置到firstTask里面去
    Runnable firstTask;
    //完成任务的计数
    volatile long completedTasks;

    /* Worker类的构造方法 */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 使用线程工厂创建新的线程
        this.thread = getThreadFactory().newThread(this);
    }

    // 重写Runnable接口的run方法
    public void run() {
        runWorker(this);
    }

    //检测是否是否获取到锁
	//state=0表示未获取到锁
	//state=1表示已获取到锁
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    //使用AQS设置线程状态
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    //尝试释放锁
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

Worker使用到了AQS的独占锁，它用**独占锁表示worker的状态**，如果这个锁是占用状态，说明占用锁的线程是worker内部封装的线程本身，表示其正在工作，它执行完业务代码后会释放锁，表示worker回归空闲

**<font color='red'>Worker启动流程：</font>**

Worker本身就是实现Runnable接口，注册到Thread中，当这个Thread启动时，会以worker.run()方法为入口，但是Worker内部的线程，并不是Worker启动的，而是提交任务的那个线程启动的。而这个线程在Worker初始化的时候创建，传入的Runnable对象正是Worker本身，因此它start()，调用的是worker.run()方法，而这个方法调用runWorker方法，runWorker方法里面最终调用了任务task.run方法执行任务代码。

## runWorker

Worker类中主要就是runWorker这个方法

```Java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    //首先拿到任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    //释放锁，将state设置为0,允许中断任务的执行
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        //传入任务不为空 或者 从阻塞队列中拿到了任务不为空
        //while循环就表示这个线程不会停止，会去取下一个任务执行
        while (task != null || (task = getTask()) != null) {
            //如果任务不为空，则获取Worker工作线程的独占锁，表示正在工作
            w.lock();
      // 当线程池是处于STOP状态或者TIDYING、TERMINATED状态时，设置当前线程处于中断状态
       // 如果不是，当前线程就处于RUNNING或者SHUTDOWN状态，确保当前线程不处于中断状态
       // 就是判断是否需要中断当前线程！！！
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                //中断线程
                wt.interrupt();
            try {
                // 调用子类实现的前置钩子算法
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //关键：把任务task给run起来，这就是我们Runnable的run方法
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 调用子类实现的后置钩子算法
                    afterExecute(task, thrown);
                }
            } finally {
                //任务执行完成，设置为null
                task = null;
                //完成任务数+1
                w.completedTasks++;
                //释放工作线程获得的锁，恢复空闲
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //整个线程结束时调用，线程退出操作。作
        processWorkerExit(w, completedAbruptly);
    }
}
```

Worker类就不断通过getTask获取任务来执行

## getTask

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        //如果当前线程池状态已经不是RUNNING，那么工作线程数-1
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        //工作线程数>核心线程数；当前线程不是最后一个线程，那么当前线程退出
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            //获取任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

问题：submit和excute?

execute返回值是void，只能接收Runnable的任务，无法抛出异常

submit返回值是Future，可以接受Runnable和Callable的任务，可以抛出异常，通过Future.get捕获抛出的异常。但是如果你传的是Runnable任务，Future.get获得的还是null

