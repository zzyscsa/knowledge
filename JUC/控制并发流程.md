# CountDownLatch

- 仅有一个构造函数，传入一个参数count为需要倒数的值
- await()：调用该方法的线程会被挂起，直到count为0才继续执行
- countDown()：将count-1，直到为0，等待的线程被唤醒

## 一等多用法

![image-20200913164330464](D:\Typora\picture\image-20200913164330464.png)

## 多等一用法

CountDownLatch(1)传入1，有多个线程await()等待，当count为0时多个线程统一唤醒



# Semaphore信号量

- 用来<font color='red'>限制</font>或管理数量<font color='red'>有限的资源</font>的使用情况
- 信号量的作用是维护一个“<font color='red'>许可证</font>”的计数，线程可以获取许可证，那信号量剩余的许可证就减一，线程也可以释放许可证，那么信号量剩余的许可证就加一，当信号量拥有的许可证为0，那么下一个线程想要获取许可证就需要等待，直至另外一个线程释放了许可证

## 使用流程

- 初始化Semaphore并指定许可证的数量
- 调用acquire()方法尝试获取许可证
- 调用release()方法释放许可证

为什么不直接使用newFixedThreadPool限制。因为只是少数部分时间服务受到最大线程数限制，这个时候使用Semaphore。其他时间可以使用线程里的所有线程



- 特殊用法：acquire(3)方法表示一次拿3个许可证，release(3)表示一次释放3个许可证

# CyclicBarrier

和CountDownLatch区别：

- 作用不同：CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说，**`CountDownLatch用于事件，CyclicBarrier用于线程`**
- 可重用性不同：CountDownLatch倒数到0并触发门闩打开后，不能再次使用，除非新建新的CountDownLatch实例；而**`CyclicBarrier可以重复使用`**

