## 微服务

微服务是一种架构风格

- 一系列微小的服务共同组成
- 跑在自己的进程里，互不干扰
- 每个服务为独立的业务开发
- 独立部署
- 分布式管理

**卖家端单体架构**：所有业务逻辑都在一个war包里面，没有依赖关系，是一个整体，用的同一个数据库，放在一个web容器上面

![image-20200818233849390](D:\Typora\picture\image-20200818233849390.png)

优点：容易测试、容易部署

缺点：开发效率低、代码维护难、部署不灵活（指的是构建时间长）、稳定性不高、扩展性不够

**买家端单体架构**：基于Ajax的前后端分离架构

![image-20200818234247207](D:\Typora\picture\image-20200818234247207.png)

![image-20200818234335843](D:\Typora\picture\image-20200818234335843.png)

## 微服务架构基础组件/框架

![image-20200818235835825](D:\Typora\picture\image-20200818235835825.png)

- 服务注册与发现：服务提供方需要注册，服务调用方从这个组件获取服务
- 服务网关：对外屏蔽后台服务的细节；路由功能，外部请求反向路由到内部某个微服务去；限流和容错功能；监控和日志功能；安全功能，用户认证，授权，反爬虫
- 后端通用服务（中间层服务）：后端服务启动的时候会把地址信息注册到服务注册表
- 前端服务（边缘服务）：查询注册表发现和调用后端服务。前端服务主要对后端服务做必要的**聚合**和**裁剪**后暴露给外部不同的设备
  - 聚合：对多个API调用逻辑进行聚合，从而减少客户端的请求数，可以把两个接口合二为一，前端只要调用后端服务一个接口
  - 裁剪：比如PC端返回的详情更详细，手机端返回详情就没那么详细

## 分布式

旨在支持应用程序和服务的开发，可以利用物理架构 由`多个自治的处理元素`，`不共享主内存`，但通过网络发送`消息`(http rest接口，RPC)合作。

多个自治处理元素表示有多个结点，集群也是多个结点。但是集群是做同一件事情，分布式是做不同的事情互不干扰。



## 是否适合微服务

### 业务形态不适合的：

- 系统中包含很多很多强事务（强一致性）场景的
- 业务相对稳定，迭代周期长
- 访问压力不大，可用性要求不高

### 团队结构不适合的：

需要小团队，才能够精细度的沟通



## 服务拆分

![image-20200819214543484](D:\Typora\picture\image-20200819214543484.png)

### 如何拆分“功能”？

- **单一职责、松耦合**（修改一个服务另一个不需要跟着修改）、**高内聚**（修改一个行为只修改一个服务）
- 关注点分离
  - 按职责：给服务分类，如订单、商品
  - 按通用性：基础组件与业务无关的可以划分出来，如消息服务、用户服务
  - 按粒度级别

### 服务和数据的关系

- 先考虑业务功能，再考虑数据
- 无状态服务：如果一个数据被多个服务共享才完成一个请求，这个数据叫做状态，进而依赖这个数据的服务叫做状态服务，反之叫做无状态服务

### 如何拆分“数据”？

- 每个微服务都有单独的数据存储
- 依据服务的特点选择不同结构的数据库类型
  - 对事物要求不高，类型丰富，使用NoSql数据库 
  - 专门做搜索类型的服务，考虑使用ES存储
  - 事务要求高的，考虑MySql
- 难点在于确定边界
  - 针对边界设计API
  - 依据边界权衡数据冗余

## 分布式追踪系统

**核心步骤**：数据采集、数据存储、查询展示



**OpenTracing**规范，解决不同分布式系统api不兼容的问题，它提供平台无关、厂商无关的api，使得开发人员能够方便添加或更换追踪系统的实现

Trace：调用链，通过归属此调用链的span来定义

Annotation：用来即时记录事件，使用一些核心注解定义请求的开始和结束，可以理解为span生命周期中重要时刻的数据快照，一般包含发生时刻、事件类型等信息

事件类型

1. cs（Client Send）：客户端发起请求时间
2. cr（Client Received）：客户端收到处理完请求的时间
3. ss（Server Send）：服务端处理完逻辑的时间
4. sr（Server Received）：服务端收到调用端请求的时间

`客户端调用时间 = cr-cs`

`服务端处理时间 = ss-sr `

## Zipkin

### **Zipkin架构**![image-20200826191650280](D:\Typora\picture\image-20200826191650280.png)

看绿色部分：

Collector：收集组件，用于处理从外部系统发送过来的跟踪信息，将这些信息转换为zipkin内部处理的span格式，以支持后续的储存、分析、展示

Storage：默认存到内存里面，也可以修改储存策略存到数据库

API：提供外部访问的RESTful接口

UI：基于API组件实现的上层应用，方便直观查询分析跟踪信息

### 关键概念

- traceId：全局的跟踪id，跟踪的入口点，根据需求决定在哪里生成traceId
- spanId：下一层的请求跟踪Id
- parentId：上一次请求的跟踪Id，串联前后请求