## 分模块

订单order服务需要调用商品product服务

初始流程：order服务里面写了一个Feign接口，这个接口从注册中心获取product服务的方法，然后调用product里面的controller处理，order服务的service是调用自己服务里面写的Feign接口。

分模块：Feign接口不再在order服务里面写，而是由product服务提供和维护（写在product服务的client模块里面），product服务将client模块打jar包，然后order服务引入这个jar包，并且指定Feign接口从这个jar包里面去找，然后调用服务，这个服务接口是写在product项目里面的，然后Feign接口对应product的controller处理。

把对方的服务定义到自己的服务里面来，显然也是不合理的，应该对方定义好接口，自己调用。一些供自己和外部服务使用的对象，也打包提供



## 异步和消息

异步：客户端请求不会阻塞进程，服务端的响应可以是非即使的

异步的常见形态：

- 通知：单向请求，一对一
- 请求/异步响应：一对一，客户端发送请求，服务端异步响应，客户端不会阻塞
- 消息：一对多

MQ应用场景：

- 异步处理
- 流量削峰：秒杀
- 日志处理
- 应用解耦



## 异步扣库存分析

下单流程：

1. 查询商品信息（调用商品服务）
2. 计算总价（生成订单详情、调用订单服务）
3. 扣库存（调用商品服务）
4. 订单入库（生成订单，调用订单服务）

订单服务和商品服务查询各自的数据库。

假如第4步订单入库改成异步，1、2、3步成功后立马回复用户，之后通过消息让订单服务异步下单，如果下单失败了，可以**重试**，如果不成功，MQ就一直存在，继续尝试下单。

假如3、4步都改成异步，那么就变得非常复杂，如果订单服务创建成功而商品服务扣减库存失败，如何回滚？可以让订单创建成功后订单的状态是**排队中**，然后发布消息到MQ，表示订单已经创建，MQ负责转发给订阅该消息的服务，如果商品服务收到消息后执行扣库存失败，不论成功还是失败，商品服务都会发送扣库存结果给MQ，订单服务收到消息如果扣减成功将订单状态改为**已确认**，如果失败就改为**已取消**



因此异步口库存（秒杀）流程：

1. 库存保存在Redis中
2. 收到请求Redis判断是否库存充足，减掉Redis中的库存
3. 订单服务创建订单，写入数据库，并发送消息
4. 如果订单入库异常，手动回滚Redis（加库存）

## 架构图

![image-20200825154600874](D:\Typora\picture\image-20200825154600874.png)

